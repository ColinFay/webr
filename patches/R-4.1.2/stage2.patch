diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/errors.c R-4.1.2_web/src/main/errors.c
--- R-4.1.2/src/main/errors.c	2021-10-15 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/main/errors.c	2022-01-19 14:55:18.937957523 +0000
@@ -1075,7 +1075,8 @@
 	}
     }
 
-    R_jumpctxt(R_ToplevelContext, 0, NULL);
+    //R_jumpctxt(R_ToplevelContext, 0, NULL);
+    R_jumpctxt(R_ToplevelContext, 1, NULL);
 }
 
 void NORET jump_to_toplevel()
@@ -1490,7 +1491,8 @@
     if (c != R_ToplevelContext)
 	warning(_("top level inconsistency?"));
 
-    R_jumpctxt(R_ToplevelContext, CTXT_TOPLEVEL, NULL);
+    //R_jumpctxt(R_ToplevelContext, CTXT_TOPLEVEL, NULL);
+    R_jumpctxt(R_ToplevelContext, 1, NULL);
 }
 #endif

diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/extra/xdr/rpc/xdr.h R-4.1.2_web/src/extra/xdr/rpc/xdr.h
--- R-4.1.2/src/extra/xdr/rpc/xdr.h	2018-09-25 08:46:43.000000000 +0000
+++ R-4.1.2_web/src/extra/xdr/rpc/xdr.h	2022-01-13 11:58:52.556848557 +0000
@@ -176,12 +176,20 @@
 #define	xdr_inline(xdrs, len)				\
 	(*(xdrs)->x_ops->x_inline)(xdrs, len)
 
+/*
 #define	XDR_DESTROY(xdrs)				\
 	if ((xdrs)->x_ops->x_destroy) 			\
 		(*(xdrs)->x_ops->x_destroy)(xdrs)
 #define	xdr_destroy(xdrs)				\
 	if ((xdrs)->x_ops->x_destroy) 			\
 		(*(xdrs)->x_ops->x_destroy)(xdrs)
+*/
+#define	XDR_DESTROY(xdrs)				\
+	if (0) 			\
+		(*(xdrs)->x_ops->x_destroy)(xdrs)
+#define	xdr_destroy(xdrs)				\
+	if (0) 			\
+		(*(xdrs)->x_ops->x_destroy)(xdrs)
 
 /*
  * Support struct for discriminated unions.
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/gpar.c R-4.1.2_web/src/library/grid/src/gpar.c
--- R-4.1.2/src/library/grid/src/gpar.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/gpar.c	2022-01-14 15:47:01.284960796 +0000
@@ -314,7 +314,7 @@
      */
     if (Rf_inherits(gpFillSXP(gp), "GridPattern")) {
         if (Rf_inherits(gpFillSXP(gp), "GridResolvedPattern")) {
-            SEXP fillRef = getListElement(gpFillSXP(gp), "ref");
+            SEXP fillRef = getListElementGrid(gpFillSXP(gp), "ref");
             gc->fill = R_TRANWHITE;
             gc->patternFill = fillRef;
         } else {
@@ -481,7 +481,7 @@
         combineAlpha(gpAlpha2(gp, i, gpIsScalar), gpCol2(gp, i, gpIsScalar));
     if (Rf_inherits(gpFillSXP(gp), "GridPattern")) {
         if (Rf_inherits(gpFillSXP(gp), "GridResolvedPattern")) {
-            SEXP fillRef = getListElement(gpFillSXP(gp), "ref");
+            SEXP fillRef = getListElementGrid(gpFillSXP(gp), "ref");
             gcCache->fill = gc->fill = R_TRANWHITE;
             gcCache->patternFill = gc->patternFill = fillRef;
         } else {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/grid.c R-4.1.2_web/src/library/grid/src/grid.c
--- R-4.1.2/src/library/grid/src/grid.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/grid.c	2022-01-14 15:46:30.864960731 +0000
@@ -429,7 +429,7 @@
      */
     {
         SEXP vpgp = PROTECT(VECTOR_ELT(pushedvp, VP_GP));
-        SEXP fill = getListElement(vpgp, "fill");
+        SEXP fill = getListElementGrid(vpgp, "fill");
         if (fill != R_NilValue) {
             /* Do not keep resolved fill because cannot release it
                * (until grid.newpage()) 
@@ -438,7 +438,7 @@
             /* Record the resolved fill for subsequent up/down/pop */
             SET_VECTOR_ELT(VECTOR_ELT(pushedvp, PVP_GPAR),
                            GP_FILL,
-                           getListElement(vpgp, "fill"));
+                           getListElementGrid(vpgp, "fill"));
             /* Ensure that the "current" gpar has the resolved fill too */
             setGridStateElement(dd, GSS_GPAR, VECTOR_ELT(pushedvp, PVP_GPAR));
         }
@@ -2498,7 +2498,7 @@
     if (!LOGICAL(o)[0] && draw) {
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -2848,7 +2848,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
@@ -2966,7 +2966,7 @@
 	GEMode(0, dd);
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -3213,7 +3213,7 @@
 	GEMode(0, dd);
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -3332,7 +3332,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
@@ -3876,7 +3876,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/grid.h R-4.1.2_web/src/library/grid/src/grid.h
--- R-4.1.2/src/library/grid/src/grid.h	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/grid.h	2022-01-14 15:46:18.884960706 +0000
@@ -462,7 +462,7 @@
 		   double *hadj, double *vadj);
 
 /* From util.c */
-SEXP getListElement(SEXP list, char *str);
+SEXP getListElementGrid(SEXP list, char *str);
 
 void setListElement(SEXP list, char *str, SEXP value);
 
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/unit.c R-4.1.2_web/src/library/grid/src/unit.c
--- R-4.1.2/src/library/grid/src/unit.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/unit.c	2022-01-14 15:46:43.576960758 +0000
@@ -232,14 +232,14 @@
 		    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 						 R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang2(findGrobFn, 
-					     getListElement(grob, "name")));
+					     getListElementGrid(grob, "name")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		} else {
 		    PROTECT(findGrobFn =findFun(install("findGrobinChildren"), 
 						R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang3(findGrobFn, 
-					     getListElement(grob, "name"),
-					     getListElement(savedgrob, 
+					     getListElementGrid(grob, "name"),
+					     getListElementGrid(savedgrob, 
 							    "children")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		}
@@ -278,14 +278,14 @@
 		    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 						 R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang2(findGrobFn, 
-					     getListElement(grob, "name")));
+					     getListElementGrid(grob, "name")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		} else {
 		    PROTECT(findGrobFn =findFun(install("findGrobinChildren"), 
 						R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang3(findGrobFn, 
-					     getListElement(grob, "name"),
-					     getListElement(savedgrob, 
+					     getListElementGrid(grob, "name"),
+					     getListElementGrid(savedgrob, 
 							    "children")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		}
@@ -414,14 +414,14 @@
 	    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 					 R_gridEvalEnv));
 	    PROTECT(R_fcall0 = lang2(findGrobFn, 
-				     getListElement(grob, "name")));
+				     getListElementGrid(grob, "name")));
 	    PROTECT(grob = eval(R_fcall0, R_gridEvalEnv));
 	} else {
 	    PROTECT(findGrobFn = findFun(install("findGrobinChildren"), 
 					 R_gridEvalEnv));
 	    PROTECT(R_fcall0 = lang3(findGrobFn, 
-				     getListElement(grob, "name"),
-				     getListElement(savedgrob, "children")));
+				     getListElementGrid(grob, "name"),
+				     getListElementGrid(savedgrob, "children")));
 	    PROTECT(grob = eval(R_fcall0, R_gridEvalEnv));
 	}
 	/*
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/util.c R-4.1.2_web/src/library/grid/src/util.c
--- R-4.1.2/src/library/grid/src/util.c	2018-09-25 08:45:08.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/util.c	2022-01-14 15:46:54.040960781 +0000
@@ -24,7 +24,7 @@
 /* Get the list element named str, or return NULL.
  * Copied from the Writing R Extensions manual (which copied it from nls)
  */
-SEXP getListElement(SEXP list, char *str)
+SEXP getListElementGrid(SEXP list, char *str)
 {
   SEXP elmt = R_NilValue;
   SEXP names = getAttrib(list, R_NamesSymbol);
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/Rstrptime.h R-4.1.2_web/src/main/Rstrptime.h
--- R-4.1.2/src/main/Rstrptime.h	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/main/Rstrptime.h	2022-01-12 11:43:33.820062492 +0000
@@ -40,7 +40,7 @@
 static int locale_strings_set = 0;
 static int locale_w_strings_set = 0;
 static void get_locale_strings(void);
-static void get_locale_w_strings(void);
+//static void get_locale_w_strings(void);
 
 
 #ifdef HAVE_STRINGS_H
@@ -276,7 +276,8 @@
 	case L'a':
 	case L'A':
 	    /* Match day of week.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	    if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	/* try full name first */
@@ -298,7 +299,8 @@
 	case L'B':
 	case L'h':
 	    /* Match month name.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	    if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	    /* try full name first */
@@ -388,7 +390,8 @@
 	  break;
 	case L'p':
 	  /* Match locale's equivalent of AM/PM.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	  if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	  if (!w_match_string (w_am_pm[0], rp)) {
@@ -1240,7 +1243,8 @@
     locale_strings_set = 1;
 }
 
-#if defined(HAVE_WCSTOD) && defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSTOD) && defined(HAVE_WCSFTIME)
+#if 0
 static void get_locale_w_strings(void)
 {
     int i;
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/arithmetic.c R-4.1.2_web/src/main/arithmetic.c
--- R-4.1.2/src/main/arithmetic.c	2021-10-15 22:15:01.000000000 +0000
+++ R-4.1.2_web/src/main/arithmetic.c	2022-01-11 16:25:07.659912454 +0000
@@ -63,6 +63,19 @@
    macOS had it for x86_64 even in 11.0, but not for arm64.
  */
 #ifndef __cplusplus
+#define DOMAIN 1
+#define SING 2
+#define OVERFLOW 3
+#define UNDERFLOW 4
+#define TLOSS 5
+#define PLOSS 6
+struct exception {
+	int    type;      /* Exception type */
+	char  *name;      /* Name of function causing exception */
+	double arg1;      /* 1st argument to function */
+	double arg2;      /* 2nd argument to function */
+	double retval;    /* Function return value */
+};
 int matherr(struct exception *exc)
 {
     switch (exc->type) {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/connections.c R-4.1.2_web/src/main/connections.c
--- R-4.1.2/src/main/connections.c	2021-07-02 22:15:02.000000000 +0000
+++ R-4.1.2_web/src/main/connections.c	2022-01-11 16:44:41.643937785 +0000
@@ -4277,21 +4277,12 @@
 	if (!strcmp(what, "integer") || !strcmp(what, "int")) {
 	    sizedef = sizeof(int); mode = 1;
 
-#if (SIZEOF_LONG == 8) && (SIZEOF_LONG > SIZEOF_INT)
-#  define CASE_LONG_ETC case sizeof(long):
-#elif (SIZEOF_LONG_LONG == 8) && (SIZEOF_LONG_LONG > SIZEOF_INT)
-#  define CASE_LONG_ETC case sizeof(_lli_t):
-#else
-#  define CASE_LONG_ETC
-#endif
-
 #define CHECK_INT_SIZES(SIZE, DEF) do {					\
 	    if(SIZE == NA_INTEGER) SIZE = DEF;				\
 	    switch (SIZE) {						\
 	    case sizeof(signed char):					\
 	    case sizeof(short):						\
 	    case sizeof(int):						\
-	    CASE_LONG_ETC						\
 		break;							\
 	    default:							\
 		error(_("size %d is unknown on this machine"), SIZE);	\
@@ -4569,25 +4560,6 @@
 	    case sizeof(int):
 		memcpy(buf, INTEGER(object), size * len);
 		break;
-#if SIZEOF_LONG == 8
-	    case sizeof(long):
-	    {
-		for (i = 0, j = 0; i < len; i++, j += size) {
-		    long l1 = (long) INTEGER(object)[i];
-		    memcpy(buf + j, &l1, size);
-		}
-		break;
-	    }
-#elif SIZEOF_LONG_LONG == 8
-	    case sizeof(_lli_t):
-	    {
-		for (i = 0, j = 0; i < len; i++, j += size) {
-		    _lli_t ll1 = (_lli_t) INTEGER(object)[i];
-		    memcpy(buf + j, &ll1, size);
-		}
-		break;
-	    }
-#endif
 	    case 2:
 	    {
 		for (i = 0, j = 0; i < len; i++, j += size) {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/devices.c R-4.1.2_web/src/main/devices.c
--- R-4.1.2/src/main/devices.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/main/devices.c	2022-01-14 10:49:15.886477961 +0000
@@ -39,12 +39,14 @@
 
 int baseRegisterIndex = -1;
 
+/*
 GPar* dpptr(pGEDevDesc dd) {
     if (baseRegisterIndex == -1)
 	error(_("the base graphics system is not registered"));
     baseSystemState *bss = dd->gesd[baseRegisterIndex]->systemSpecific;
     return &(bss->dp);
 }
+*/
 
 static SEXP R_INLINE getSymbolValue(SEXP symbol)
 {
diff -ur R-4.1.2_web/src/library/stats/src/kmns.f R-4.1.2/src/library/stats/src/kmns.f
--- R-4.1.2/src/library/stats/src/kmns.f 2022-01-20 16:33:52.671125462 +0000
+++ R-4.1.2_web/src/library/stats/src/kmns.f     2019-06-02 23:15:02.000000000 +0100
@@ -440,7 +440,7 @@
    60   IF (ICOUN .EQ. M) RETURN
       end do

-      call rchkusr() ! allow user interrupt
+      call rchkusr(0) ! allow user interrupt
       GO TO 10
 c     --------
       END
diff -ur R-4.1.2_web/src/library/stats/src/ppr.f R-4.1.2/src/library/stats/src/ppr.f
--- R-4.1.2/src/library/stats/src/ppr.f  2022-01-20 16:34:05.299323950 +0000
+++ R-4.1.2_web/src/library/stats/src/ppr.f 2018-09-25 09:44:49.000000000 +0100
@@ -180,7 +180,7 @@
       asr(1)=big
       lm=0
       do 100 l=1,m
-         call rchkusr()
+         call rchkusr(0)
          lm=lm+1
          asrold=asr(1)
          call newb(lm,q,ww,b)
--- R-4.1.2/src/main/util.c 2022-01-20 16:34:43.155918958 +0000
+++ R-4.1.2_web/src/main/util.c 2021-07-02 23:15:02.000000000 +0100
@@ -1754,7 +1754,7 @@
     warning("%s", buf);
 }

-void F77_SYMBOL(rchkusr)(void)
+void F77_SYMBOL(rchkusr)(int dummy)
 {
     R_CheckUserInterrupt();
 }
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/main.c R-4.1.2_web/src/main/main.c
--- R-4.1.2/src/main/main.c 2021-09-30 10:22:47.000000000 +0100                                                                                                                                                                               +++ R-4.1.2_web/src/main/main.c 2022-01-21 17:29:19.381163092 +0000                                                                                                                                                                           @@ -206,7 +206,7 @@                                                                                                                                                                                                                                /* clear warnings that might have accumulated during a jump to top level */                                                                                                                                                                   if (R_CollectWarnings)                                                                                                                                                                                                                         PrintWarnings();                                                                                                                                                                                                                        -                                                                                                                                                                                                                                             +
     if(!*state->bufp) {
          R_Busy(0);
          if (R_ReadConsole(R_PromptString(browselevel, state->prompt_type),
@@ -300,26 +300,68 @@
     return(0);
 }

+
+#include <emscripten.h>
+#include <emscripten/fetch.h>
+
+R_ReplState global_repl_state_async;
+SEXP global_rho_async;
+int global_savestack_async;
+int global_browselevel_async;
+
+int EMSCRIPTEN_KEEPALIVE run_R_from_JS(unsigned char* evalString, unsigned int n) {
+    R_IoBufferReadReset(&R_ConsoleIob);
+    R_IoBufferWriteReset(&R_ConsoleIob);
+    if(SETJMP(R_ToplevelContext->cjmpbuf) > 0){
+        return -1;
+    }
+    unsigned char * buf = (unsigned char *) malloc(n+2);
+    strncpy((char*) buf, (char*)evalString, n);
+    buf[n] = '\n';
+    buf[n+1] = '\0';
+    global_repl_state_async.bufp = buf;
+    while(*global_repl_state_async.bufp && Rf_ReplIteration(global_rho_async, global_savestack_async, global_browselevel_async, &global_repl_state_async) >= 0);
+    free(buf);
+    free(evalString);
+    return 0;
+}
+
+void repl_read_success(emscripten_fetch_t *fetch) {
+    memset(global_repl_state_async.buf, 0, CONSOLE_BUFFER_SIZE+1);
+    strncpy((char*)(global_repl_state_async.buf), fetch->data, CONSOLE_BUFFER_SIZE+1);
+    global_repl_state_async.buf[fetch->numBytes] = '\n';
+    global_repl_state_async.buf[fetch->numBytes+1] = '\0';
+    emscripten_fetch_close(fetch);
+    if(SETJMP(R_ToplevelContext->cjmpbuf) > 0){
+        R_IoBufferReadReset(&R_ConsoleIob);
+     R_IoBufferWriteReset(&R_ConsoleIob);
+     memset(global_repl_state_async.buf, 0, CONSOLE_BUFFER_SIZE+1);
+    }
+    global_repl_state_async.bufp = global_repl_state_async.buf;
+    while(Rf_ReplIteration(global_rho_async, global_savestack_async, global_browselevel_async, &global_repl_state_async) >= 0);
+}
+
+void repl_read_fail(emscripten_fetch_t *fetch) {
+    emscripten_fetch_close(fetch);
+}
+
 static void R_ReplConsole(SEXP rho, int savestack, int browselevel)
 {
-    int status;
-    R_ReplState state = { PARSE_NULL, 1, 0, "", NULL};
+    global_repl_state_async.status = PARSE_NULL;
+    global_repl_state_async.prompt_type = 1;
+    global_repl_state_async.browselevel = 0;
+    global_repl_state_async.bufp = NULL;

     R_IoBufferWriteReset(&R_ConsoleIob);
-    state.buf[0] = '\0';
-    state.buf[CONSOLE_BUFFER_SIZE] = '\0';
-    /* stopgap measure if line > CONSOLE_BUFFER_SIZE chars */
-    state.bufp = state.buf;
-    if(R_Verbose)
-     REprintf(" >R_ReplConsole(): before \"for(;;)\" {main.c}\n");
-    for(;;) {
-     status = Rf_ReplIteration(rho, savestack, browselevel, &state);
-     if(status < 0) {
-       if (state.status == PARSE_INCOMPLETE)
-         error(_("unexpected end of input"));
-       return;
-     }
-    }
+
+    global_repl_state_async.buf[0] = '\0';
+    global_repl_state_async.buf[CONSOLE_BUFFER_SIZE] = '\0';
+    global_repl_state_async.bufp = global_repl_state_async.buf;
+    global_rho_async = rho;
+    global_savestack_async = savestack;
+    global_browselevel_async = browselevel;
+
+    Rf_ReplIteration(global_rho_async, global_savestack_async, global_browselevel_async, &global_repl_state_async);
 }


@@ -647,7 +689,7 @@
 #ifdef HAVE_STACK_T
 static stack_t sigstk;
 #else
-static struct sigaltstack sigstk;
+//static struct sigaltstack sigstk;
 #endif
 static void *signal_stack;

@@ -667,8 +709,8 @@
          sigstk.ss_sp = signal_stack;
          sigstk.ss_size = SIGSTKSZ + R_USAGE;
          sigstk.ss_flags = 0;
-         if(sigaltstack(&sigstk, NULL) < 0)
-       warning("failed to set alternate signal stack");
+           //if(sigaltstack(&sigstk, NULL) < 0)
+           //  warning("failed to set alternate signal stack");
      } else
          warning("failed to allocate alternate signal stack");
      sa.sa_sigaction = sigactionSegv;
@@ -1128,7 +1170,7 @@
      check_session_exit();
     R_GlobalContext = R_ToplevelContext = R_SessionContext = &R_Toplevel;
     R_ReplConsole(R_GlobalEnv, 0, 0);
-    end_Rmainloop(); /* must go here */
+    // end_Rmainloop(); /* must go here */
 }

 void mainloop(void)
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/dynload.c R-4.1.2_web/src/unix/dynload.c
--- R-4.1.2/src/unix/dynload.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/unix/dynload.c	2022-01-13 21:58:17.099380100 +0000
@@ -200,7 +201,8 @@
 static DL_FUNC R_local_dlsym(DllInfo *info, char const *name)
 {
     fn_ptr tmp;
-    tmp.p = dlsym(info->handle, name);
+    //tmp.p = dlsym(info->handle, name);
+    tmp.p = dlsym(RTLD_DEFAULT, name);
     return tmp.fn;
 }
 
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/sys-std.c R-4.1.2_web/src/unix/sys-std.c
--- R-4.1.2/src/unix/sys-std.c	2021-09-28 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/unix/sys-std.c	2022-01-19 13:26:13.705584920 +0000
@@ -49,6 +49,7 @@
 #include <R_ext/Riconv.h>
 #include <R_ext/Print.h> // for REprintf
 #include <R_ext/RS.h> // for Calloc
+#include "Parse.h"
 
 #define __SYSTEM__
 /* includes <sys/select.h> and <sys/time.h> */
@@ -949,6 +950,12 @@
 /* Fill a text buffer from stdin or with user typed console input. */
 static void *cd = NULL;
 
+
+#include <emscripten/fetch.h>
+#include <emscripten.h>
+void repl_read_success(emscripten_fetch_t *fetch);
+void repl_read_fail(emscripten_fetch_t *fetch);
+
 int attribute_hidden
 Rstd_ReadConsole(const char *prompt, unsigned char *buf, int len,
 		 int addtohistory)
@@ -1026,8 +1033,8 @@
 	else
 #endif /* HAVE_LIBREADLINE */
 	{
-	    fputs(prompt, stdout);
-	    fflush(stdout);
+           //fputs(prompt, stdout);
+           //fflush(stdout);
 	}
 
 	if(R_InputHandlers == NULL)
@@ -1085,10 +1092,16 @@
 		else
 #endif /* HAVE_LIBREADLINE */
 		{
-		    if(fgets((char *)buf, len, stdin) == NULL)
-			return 0;
-		    else
-			return 1;
+                    char scr[1024];
+                    sprintf(scr, "___terminal::read::%s", prompt);
+                    emscripten_fetch_attr_t attr;
+                    emscripten_fetch_attr_init(&attr);
+                    strcpy(attr.requestMethod, "GET");
+                    attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY;
+                    attr.onsuccess = repl_read_success;
+                    attr.onerror = repl_read_fail;
+                    emscripten_fetch(&attr, scr);
+                    return 0;
 		}
 	    }
 	}
@@ -1334,7 +1347,7 @@
     R_ReadConsole("Enter file name: ", (unsigned char *)buf, len, 0);
     namelen = strlen(buf);
     bufp = &buf[namelen - 1];
-    while (bufp >= buf && isspace((int)*bufp))
+    while (bufp >= buf && ((char)*bufp == ' ' || (char)*bufp == '\t' ))
 	*bufp-- = '\0';
     return (int) strlen(buf);
 }
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/sys-unix.c R-4.1.2_web/src/unix/sys-unix.c
--- R-4.1.2/src/unix/sys-unix.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/unix/sys-unix.c	2022-01-12 16:33:53.612438356 +0000
@@ -237,7 +237,8 @@
     /* docs say this is rounded to the nearest ms */
     double et = currentTime() - StartTime;
     data[2] = 1e-3 * rint(1000*et);
-#ifdef HAVE_GETRUSAGE
+//#ifdef HAVE_GETRUSAGE
+#if 0
     /* all known current OSes */
     struct rusage self, children;
     getrusage(RUSAGE_SELF, &self);
@@ -445,8 +446,8 @@
     sigprocmask(SIG_BLOCK, &ss, &unblocked_ss);
 
     int saveerrno = errno;
-    while((wres = waitpid(tost.child_pid, wstatus, WNOHANG)) == 0)
-	sigsuspend(&unblocked_ss);
+    //while((wres = waitpid(tost.child_pid, wstatus, WNOHANG)) == 0)
+    //    sigsuspend(&unblocked_ss);
 
     if (errno == EINTR)
 	/* EINTR is not really an error but expected situation here, however,
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/system.c R-4.1.2_web/src/unix/system.c
--- R-4.1.2/src/unix/system.c	2021-04-20 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/unix/system.c	2022-01-19 15:21:14.958574421 +0000
@@ -133,6 +133,7 @@
     }
 }
 
+#undef HAVE_GETRLIMIT
 #if defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT)
 /*
   Needed by AIX and formerly by macOS (but not by POSIX).
--- R-4.1.2/src/include/Rinternals.h 2021-07-01 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/include/Rinternals.h     2022-01-21 11:55:38.649300416 +0000
@@ -64,9 +64,9 @@
 # include <Rconfig.h>
 #endif

-#if ( SIZEOF_SIZE_T > 4 )
-# define LONG_VECTOR_SUPPORT
-#endif
+//#if ( SIZEOF_SIZE_T > 4 )
+//# define LONG_VECTOR_SUPPORT
+//#endif

 #ifdef LONG_VECTOR_SUPPORT
     typedef ptrdiff_t R_xlen_t;
--- R-4.1.2/src/main/eval.c 2021-06-19 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/main/eval.c 2022-01-21 11:55:54.569544295 +0000
@@ -1708,7 +1708,7 @@
          refs -= countCycleRefs(rho, val);
      if (refs == 0) {
          for (SEXP b = FRAME(rho);
-        b != R_NilValue && REFCNT(b) == 1;
+        b != R_NilValue && REFCNT(b) == 1 && ((unsigned int)CDR(b))<0x30000000;
         b = CDR(b)) {
        if (BNDCELL_TAG(b)) continue;
        SEXP v = CAR(b);
--- R-4.1.2/src/main/envir.c    2021-04-23 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/main/envir.c     2022-01-21 14:00:01.706412642 +0000
@@ -920,6 +920,7 @@
      frame = FRAME(rho);
      while (frame != R_NilValue && TAG(frame) != symbol)
          frame = CDR(frame);
+         if((unsigned int) frame > 0x30000000) return R_NilValue;
      return frame;
     }
     else {
@@ -1032,6 +1033,7 @@
          if (TAG(frame) == symbol)
        return BINDING_VALUE(frame);
          frame = CDR(frame);
+         if((unsigned int) frame > 0x30000000) return R_UnboundValue;
      }
     }
     else {
@@ -1081,6 +1083,7 @@
          if (TAG(frame) == symbol)
        return TRUE;
          frame = CDR(frame);
+         if((unsigned int) frame > 0x30000000) return FALSE;
      }
     }
     else {
@@ -1765,6 +1768,7 @@
        return symbol;
          }
          frame = CDR(frame);
+         if((unsigned int) frame > 0x30000000) return R_NilValue;
      }
     } else {
      /* Do the hash table thing */
--- R-4.1.2/src/main/dotcode.c  2021-04-19 23:02:06.000000000 +0100
+++ R-4.1.2_web/src/main/dotcode.c      2022-01-27 13:27:17.724512747 +0000
@@ -585,11 +585,49 @@
 typedef DL_FUNC VarFun;
 #endif

+#include <emscripten.h>
+EM_JS(SEXP, call_trampoline, (VarFun func,
+        void*   a0, void*  a1, void*  a2, void*  a3, void*  a4, void*  a5 , void* a6, void*  a7, void*  a8, void*  a9,
+        void*  a10, void* a11, void* a12, void* a13, void* a14, void* a15, void* a16, void* a17, void* a18, void* a19,
+        void*  a20, void* a21, void* a22, void* a23, void* a24, void* a25, void* a26, void* a27, void* a28, void* a29,
+        void*  a30, void* a31, void* a32, void* a33, void* a34, void* a35, void* a36, void* a37, void* a38, void* a39,
+        void*  a40, void* a41, void* a42, void* a43, void* a44, void* a45, void* a46, void* a47, void* a48, void* a49,
+        void*  a50, void* a51, void* a52, void* a53, void* a54, void* a55, void* a56, void* a57, void* a58, void* a59,
+        void*  a60, void* a61, void* a62, void* a63, void* a64
+    ), {
+    return wasmTable.get(func)(
+        a0,  a1,  a2,  a3,  a4,  a5 , a6,  a7,  a8,  a9,
+       a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
+       a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
+       a30, a31, a32, a33, a34, a35, a36, a37, a38, a39,
+       a40, a41, a42, a43, a44, a45, a46, a47, a48, a49,
+       a50, a51, a52, a53, a54, a55, a56, a57, a58, a59,
+       a60, a61, a62, a63, a64
+    );
+});
+
+
 SEXP attribute_hidden R_doDotCall(DL_FUNC ofun, int nargs, SEXP *cargs,
                                  SEXP call) {
     VarFun fun = NULL;
     SEXP retval = R_NilValue;  /* -Wall */
     fun = (VarFun) ofun;
+    retval = call_trampoline(fun,
+        cargs[0],  cargs[1],  cargs[2],  cargs[3],  cargs[4],
+        cargs[5],  cargs[6],  cargs[7],  cargs[8],  cargs[9],
+        cargs[10], cargs[11], cargs[12], cargs[13], cargs[14],
+        cargs[15], cargs[16], cargs[17], cargs[18], cargs[19],
+        cargs[20], cargs[21], cargs[22], cargs[23], cargs[24],
+        cargs[25], cargs[26], cargs[27], cargs[28], cargs[29],
+        cargs[30], cargs[31], cargs[32], cargs[33], cargs[34],
+        cargs[35], cargs[36], cargs[37], cargs[38], cargs[39],
+        cargs[40], cargs[41], cargs[42], cargs[43], cargs[44],
+        cargs[45], cargs[46], cargs[47], cargs[48], cargs[49],
+        cargs[50], cargs[51], cargs[52], cargs[53], cargs[54],
+        cargs[55], cargs[56], cargs[57], cargs[58], cargs[59],
+        cargs[60], cargs[61], cargs[62], cargs[63], cargs[64]
+    );
+    /*
     switch (nargs) {
     case 0:
        retval = (SEXP)ofun();
@@ -1243,6 +1281,7 @@
     default:
        errorcall(call, _("too many arguments, sorry"));
     }
+*/
     return check_retval(call, retval);
 }

@@ -1792,10 +1831,26 @@
        if (nprotect) UNPROTECT(nprotect);
     }

+    call_trampoline(fun,
+        cargs[0],  cargs[1],  cargs[2],  cargs[3],  cargs[4],
+        cargs[5],  cargs[6],  cargs[7],  cargs[8],  cargs[9],
+        cargs[10], cargs[11], cargs[12], cargs[13], cargs[14],
+        cargs[15], cargs[16], cargs[17], cargs[18], cargs[19],
+        cargs[20], cargs[21], cargs[22], cargs[23], cargs[24],
+        cargs[25], cargs[26], cargs[27], cargs[28], cargs[29],
+        cargs[30], cargs[31], cargs[32], cargs[33], cargs[34],
+        cargs[35], cargs[36], cargs[37], cargs[38], cargs[39],
+        cargs[40], cargs[41], cargs[42], cargs[43], cargs[44],
+        cargs[45], cargs[46], cargs[47], cargs[48], cargs[49],
+        cargs[50], cargs[51], cargs[52], cargs[53], cargs[54],
+        cargs[55], cargs[56], cargs[57], cargs[58], cargs[59],
+        cargs[60], cargs[61], cargs[62], cargs[63], cargs[64]
+    );
+/*
     switch (nargs) {
     case 0:
-       /* Silicon graphics C chokes here */
-       /* if there is no argument to fun. */
+       // Silicon graphics C chokes here
+       // if there is no argument to fun.
        fun(0);
        break;
     case 1:
@@ -2386,6 +2441,7 @@
     default:
        errorcall(call, _("too many arguments, sorry"));
     }
+*/

     for (na = 0, pa = args ; pa != R_NilValue ; pa = CDR(pa), na++) {
        void *p = cargs[na];
--- R-4.1.2/src/main/memory.c   2021-04-23 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/main/memory.c       2022-01-28 14:19:58.494170006 +0000
@@ -604,7 +604,7 @@
    some ways, but will create more floating garbage and add a bit to
    the execution time, though the difference is probably marginal on
    both counts.*/
-/*#define EXPEL_OLD_TO_NEW*/
+#define EXPEL_OLD_TO_NEW
 static struct {
     SEXP Old[NUM_OLD_GENERATIONS], New, Free;
     SEXPREC OldPeg[NUM_OLD_GENERATIONS], NewPeg;

