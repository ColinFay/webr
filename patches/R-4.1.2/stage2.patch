diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/errors.c R-4.1.2_web/src/main/errors.c
--- R-4.1.2/src/main/errors.c	2021-10-15 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/main/errors.c	2022-01-19 14:55:18.937957523 +0000
@@ -1075,7 +1075,8 @@
 	}
     }
 
-    R_jumpctxt(R_ToplevelContext, 0, NULL);
+    //R_jumpctxt(R_ToplevelContext, 0, NULL);
+    R_jumpctxt(R_ToplevelContext, 1, NULL);
 }
 
 void NORET jump_to_toplevel()
@@ -1490,7 +1491,8 @@
     if (c != R_ToplevelContext)
 	warning(_("top level inconsistency?"));
 
-    R_jumpctxt(R_ToplevelContext, CTXT_TOPLEVEL, NULL);
+    //R_jumpctxt(R_ToplevelContext, CTXT_TOPLEVEL, NULL);
+    R_jumpctxt(R_ToplevelContext, 1, NULL);
 }
 #endif

diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/extra/xdr/rpc/xdr.h R-4.1.2_web/src/extra/xdr/rpc/xdr.h
--- R-4.1.2/src/extra/xdr/rpc/xdr.h	2018-09-25 08:46:43.000000000 +0000
+++ R-4.1.2_web/src/extra/xdr/rpc/xdr.h	2022-01-13 11:58:52.556848557 +0000
@@ -176,12 +176,20 @@
 #define	xdr_inline(xdrs, len)				\
 	(*(xdrs)->x_ops->x_inline)(xdrs, len)
 
+/*
 #define	XDR_DESTROY(xdrs)				\
 	if ((xdrs)->x_ops->x_destroy) 			\
 		(*(xdrs)->x_ops->x_destroy)(xdrs)
 #define	xdr_destroy(xdrs)				\
 	if ((xdrs)->x_ops->x_destroy) 			\
 		(*(xdrs)->x_ops->x_destroy)(xdrs)
+*/
+#define	XDR_DESTROY(xdrs)				\
+	if (0) 			\
+		(*(xdrs)->x_ops->x_destroy)(xdrs)
+#define	xdr_destroy(xdrs)				\
+	if (0) 			\
+		(*(xdrs)->x_ops->x_destroy)(xdrs)
 
 /*
  * Support struct for discriminated unions.
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/gpar.c R-4.1.2_web/src/library/grid/src/gpar.c
--- R-4.1.2/src/library/grid/src/gpar.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/gpar.c	2022-01-14 15:47:01.284960796 +0000
@@ -314,7 +314,7 @@
      */
     if (Rf_inherits(gpFillSXP(gp), "GridPattern")) {
         if (Rf_inherits(gpFillSXP(gp), "GridResolvedPattern")) {
-            SEXP fillRef = getListElement(gpFillSXP(gp), "ref");
+            SEXP fillRef = getListElementGrid(gpFillSXP(gp), "ref");
             gc->fill = R_TRANWHITE;
             gc->patternFill = fillRef;
         } else {
@@ -481,7 +481,7 @@
         combineAlpha(gpAlpha2(gp, i, gpIsScalar), gpCol2(gp, i, gpIsScalar));
     if (Rf_inherits(gpFillSXP(gp), "GridPattern")) {
         if (Rf_inherits(gpFillSXP(gp), "GridResolvedPattern")) {
-            SEXP fillRef = getListElement(gpFillSXP(gp), "ref");
+            SEXP fillRef = getListElementGrid(gpFillSXP(gp), "ref");
             gcCache->fill = gc->fill = R_TRANWHITE;
             gcCache->patternFill = gc->patternFill = fillRef;
         } else {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/grid.c R-4.1.2_web/src/library/grid/src/grid.c
--- R-4.1.2/src/library/grid/src/grid.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/grid.c	2022-01-14 15:46:30.864960731 +0000
@@ -429,7 +429,7 @@
      */
     {
         SEXP vpgp = PROTECT(VECTOR_ELT(pushedvp, VP_GP));
-        SEXP fill = getListElement(vpgp, "fill");
+        SEXP fill = getListElementGrid(vpgp, "fill");
         if (fill != R_NilValue) {
             /* Do not keep resolved fill because cannot release it
                * (until grid.newpage()) 
@@ -438,7 +438,7 @@
             /* Record the resolved fill for subsequent up/down/pop */
             SET_VECTOR_ELT(VECTOR_ELT(pushedvp, PVP_GPAR),
                            GP_FILL,
-                           getListElement(vpgp, "fill"));
+                           getListElementGrid(vpgp, "fill"));
             /* Ensure that the "current" gpar has the resolved fill too */
             setGridStateElement(dd, GSS_GPAR, VECTOR_ELT(pushedvp, PVP_GPAR));
         }
@@ -2498,7 +2498,7 @@
     if (!LOGICAL(o)[0] && draw) {
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -2848,7 +2848,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
@@ -2966,7 +2966,7 @@
 	GEMode(0, dd);
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -3213,7 +3213,7 @@
 	GEMode(0, dd);
         if (resolvedFill != R_NilValue &&
             Rf_inherits(resolvedFill, "GridGrobPattern")) {
-            SEXP patternRef = getListElement(resolvedFill, "index");
+            SEXP patternRef = getListElementGrid(resolvedFill, "index");
             dd->dev->releasePattern(patternRef, dd->dev);
         }
         UNPROTECT(1); /* resolvedFill */
@@ -3332,7 +3332,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
@@ -3876,7 +3876,7 @@
     GEMode(0, dd);
     if (resolvedFill != R_NilValue &&
         Rf_inherits(resolvedFill, "GridGrobPattern")) {
-        SEXP patternRef = getListElement(resolvedFill, "index");
+        SEXP patternRef = getListElementGrid(resolvedFill, "index");
         dd->dev->releasePattern(patternRef, dd->dev);
     }
     UNPROTECT(1); /* resolvedFill */
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/grid.h R-4.1.2_web/src/library/grid/src/grid.h
--- R-4.1.2/src/library/grid/src/grid.h	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/grid.h	2022-01-14 15:46:18.884960706 +0000
@@ -462,7 +462,7 @@
 		   double *hadj, double *vadj);
 
 /* From util.c */
-SEXP getListElement(SEXP list, char *str);
+SEXP getListElementGrid(SEXP list, char *str);
 
 void setListElement(SEXP list, char *str, SEXP value);
 
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/unit.c R-4.1.2_web/src/library/grid/src/unit.c
--- R-4.1.2/src/library/grid/src/unit.c	2021-04-19 22:02:04.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/unit.c	2022-01-14 15:46:43.576960758 +0000
@@ -232,14 +232,14 @@
 		    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 						 R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang2(findGrobFn, 
-					     getListElement(grob, "name")));
+					     getListElementGrid(grob, "name")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		} else {
 		    PROTECT(findGrobFn =findFun(install("findGrobinChildren"), 
 						R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang3(findGrobFn, 
-					     getListElement(grob, "name"),
-					     getListElement(savedgrob, 
+					     getListElementGrid(grob, "name"),
+					     getListElementGrid(savedgrob, 
 							    "children")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		}
@@ -278,14 +278,14 @@
 		    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 						 R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang2(findGrobFn, 
-					     getListElement(grob, "name")));
+					     getListElementGrid(grob, "name")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		} else {
 		    PROTECT(findGrobFn =findFun(install("findGrobinChildren"), 
 						R_gridEvalEnv));
 		    PROTECT(R_fcall0 = lang3(findGrobFn, 
-					     getListElement(grob, "name"),
-					     getListElement(savedgrob, 
+					     getListElementGrid(grob, "name"),
+					     getListElementGrid(savedgrob, 
 							    "children")));
 		    grob = eval(R_fcall0, R_gridEvalEnv);
 		}
@@ -414,14 +414,14 @@
 	    PROTECT(findGrobFn = findFun(install("findGrobinDL"), 
 					 R_gridEvalEnv));
 	    PROTECT(R_fcall0 = lang2(findGrobFn, 
-				     getListElement(grob, "name")));
+				     getListElementGrid(grob, "name")));
 	    PROTECT(grob = eval(R_fcall0, R_gridEvalEnv));
 	} else {
 	    PROTECT(findGrobFn = findFun(install("findGrobinChildren"), 
 					 R_gridEvalEnv));
 	    PROTECT(R_fcall0 = lang3(findGrobFn, 
-				     getListElement(grob, "name"),
-				     getListElement(savedgrob, "children")));
+				     getListElementGrid(grob, "name"),
+				     getListElementGrid(savedgrob, "children")));
 	    PROTECT(grob = eval(R_fcall0, R_gridEvalEnv));
 	}
 	/*
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/library/grid/src/util.c R-4.1.2_web/src/library/grid/src/util.c
--- R-4.1.2/src/library/grid/src/util.c	2018-09-25 08:45:08.000000000 +0000
+++ R-4.1.2_web/src/library/grid/src/util.c	2022-01-14 15:46:54.040960781 +0000
@@ -24,7 +24,7 @@
 /* Get the list element named str, or return NULL.
  * Copied from the Writing R Extensions manual (which copied it from nls)
  */
-SEXP getListElement(SEXP list, char *str)
+SEXP getListElementGrid(SEXP list, char *str)
 {
   SEXP elmt = R_NilValue;
   SEXP names = getAttrib(list, R_NamesSymbol);
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/Rstrptime.h R-4.1.2_web/src/main/Rstrptime.h
--- R-4.1.2/src/main/Rstrptime.h	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/main/Rstrptime.h	2022-01-12 11:43:33.820062492 +0000
@@ -40,7 +40,7 @@
 static int locale_strings_set = 0;
 static int locale_w_strings_set = 0;
 static void get_locale_strings(void);
-static void get_locale_w_strings(void);
+//static void get_locale_w_strings(void);
 
 
 #ifdef HAVE_STRINGS_H
@@ -276,7 +276,8 @@
 	case L'a':
 	case L'A':
 	    /* Match day of week.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	    if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	/* try full name first */
@@ -298,7 +299,8 @@
 	case L'B':
 	case L'h':
 	    /* Match month name.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	    if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	    /* try full name first */
@@ -388,7 +390,8 @@
 	  break;
 	case L'p':
 	  /* Match locale's equivalent of AM/PM.  */
-#if defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSFTIME)
+#if 0
 	  if(!locale_w_strings_set) get_locale_w_strings();
 #endif
 	  if (!w_match_string (w_am_pm[0], rp)) {
@@ -1240,7 +1243,8 @@
     locale_strings_set = 1;
 }
 
-#if defined(HAVE_WCSTOD) && defined(HAVE_WCSFTIME)
+//#if defined(HAVE_WCSTOD) && defined(HAVE_WCSFTIME)
+#if 0
 static void get_locale_w_strings(void)
 {
     int i;
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/arithmetic.c R-4.1.2_web/src/main/arithmetic.c
--- R-4.1.2/src/main/arithmetic.c	2021-10-15 22:15:01.000000000 +0000
+++ R-4.1.2_web/src/main/arithmetic.c	2022-01-11 16:25:07.659912454 +0000
@@ -63,6 +63,19 @@
    macOS had it for x86_64 even in 11.0, but not for arm64.
  */
 #ifndef __cplusplus
+#define DOMAIN 1
+#define SING 2
+#define OVERFLOW 3
+#define UNDERFLOW 4
+#define TLOSS 5
+#define PLOSS 6
+struct exception {
+	int    type;      /* Exception type */
+	char  *name;      /* Name of function causing exception */
+	double arg1;      /* 1st argument to function */
+	double arg2;      /* 2nd argument to function */
+	double retval;    /* Function return value */
+};
 int matherr(struct exception *exc)
 {
     switch (exc->type) {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/connections.c R-4.1.2_web/src/main/connections.c
--- R-4.1.2/src/main/connections.c	2021-07-02 22:15:02.000000000 +0000
+++ R-4.1.2_web/src/main/connections.c	2022-01-11 16:44:41.643937785 +0000
@@ -4277,21 +4277,12 @@
 	if (!strcmp(what, "integer") || !strcmp(what, "int")) {
 	    sizedef = sizeof(int); mode = 1;
 
-#if (SIZEOF_LONG == 8) && (SIZEOF_LONG > SIZEOF_INT)
-#  define CASE_LONG_ETC case sizeof(long):
-#elif (SIZEOF_LONG_LONG == 8) && (SIZEOF_LONG_LONG > SIZEOF_INT)
-#  define CASE_LONG_ETC case sizeof(_lli_t):
-#else
-#  define CASE_LONG_ETC
-#endif
-
 #define CHECK_INT_SIZES(SIZE, DEF) do {					\
 	    if(SIZE == NA_INTEGER) SIZE = DEF;				\
 	    switch (SIZE) {						\
 	    case sizeof(signed char):					\
 	    case sizeof(short):						\
 	    case sizeof(int):						\
-	    CASE_LONG_ETC						\
 		break;							\
 	    default:							\
 		error(_("size %d is unknown on this machine"), SIZE);	\
@@ -4569,25 +4560,6 @@
 	    case sizeof(int):
 		memcpy(buf, INTEGER(object), size * len);
 		break;
-#if SIZEOF_LONG == 8
-	    case sizeof(long):
-	    {
-		for (i = 0, j = 0; i < len; i++, j += size) {
-		    long l1 = (long) INTEGER(object)[i];
-		    memcpy(buf + j, &l1, size);
-		}
-		break;
-	    }
-#elif SIZEOF_LONG_LONG == 8
-	    case sizeof(_lli_t):
-	    {
-		for (i = 0, j = 0; i < len; i++, j += size) {
-		    _lli_t ll1 = (_lli_t) INTEGER(object)[i];
-		    memcpy(buf + j, &ll1, size);
-		}
-		break;
-	    }
-#endif
 	    case 2:
 	    {
 		for (i = 0, j = 0; i < len; i++, j += size) {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/devices.c R-4.1.2_web/src/main/devices.c
--- R-4.1.2/src/main/devices.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/main/devices.c	2022-01-14 10:49:15.886477961 +0000
@@ -39,12 +39,14 @@
 
 int baseRegisterIndex = -1;
 
+/*
 GPar* dpptr(pGEDevDesc dd) {
     if (baseRegisterIndex == -1)
 	error(_("the base graphics system is not registered"));
     baseSystemState *bss = dd->gesd[baseRegisterIndex]->systemSpecific;
     return &(bss->dp);
 }
+*/
 
 static SEXP R_INLINE getSymbolValue(SEXP symbol)
 {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/envir.c R-4.1.2_web/src/main/envir.c
--- R-4.1.2/src/main/envir.c	2021-04-23 22:15:01.000000000 +0000
+++ R-4.1.2_web/src/main/envir.c	2022-01-14 10:35:02.520139147 +0000
@@ -915,11 +915,12 @@
 	}
 	return(tmp);
     }
-
     if (HASHTAB(rho) == R_NilValue) {
 	frame = FRAME(rho);
-	while (frame != R_NilValue && TAG(frame) != symbol)
+	while (frame != R_NilValue && TAG(frame) != symbol){
 	    frame = CDR(frame);
+            if (frame == 0x3ff00000) return R_NilValue;
+        }
 	return frame;
     }
     else {
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/main/main.c R-4.1.2_web/src/main/main.c
--- R-4.1.2/src/main/main.c	2021-09-30 10:22:47.000000000 +0100
+++ R-4.1.2_web/src/main/main.c	2022-01-19 15:08:07.182116383 +0000
@@ -300,26 +300,51 @@
     return(0);
 }
 
+
+#include <emscripten.h>
+#include <emscripten/fetch.h>
+
+R_ReplState global_repl_state_async;
+SEXP global_rho_async;
+int global_savestack_async;
+int global_browselevel_async;
+
+void repl_read_success(emscripten_fetch_t *fetch) {
+    memset(global_repl_state_async.buf, 0, CONSOLE_BUFFER_SIZE+1);
+    strncpy((char*)(global_repl_state_async.buf), fetch->data, CONSOLE_BUFFER_SIZE+1);
+    global_repl_state_async.buf[fetch->numBytes] = '\n';
+    global_repl_state_async.buf[fetch->numBytes+1] = '\0';
+    emscripten_fetch_close(fetch);
+    if(SETJMP(R_ToplevelContext->cjmpbuf) > 0){
+        R_IoBufferReadReset(&R_ConsoleIob);
+	R_IoBufferWriteReset(&R_ConsoleIob);
+	memset(global_repl_state_async.buf, 0, CONSOLE_BUFFER_SIZE+1);
+    }
+    global_repl_state_async.bufp = global_repl_state_async.buf;
+    while(Rf_ReplIteration(global_rho_async, global_savestack_async, global_browselevel_async, &global_repl_state_async) >= 0);
+}
+
+void repl_read_fail(emscripten_fetch_t *fetch) {
+    emscripten_fetch_close(fetch);
+}
+
 static void R_ReplConsole(SEXP rho, int savestack, int browselevel)
 {
-    int status;
-    R_ReplState state = { PARSE_NULL, 1, 0, "", NULL};
+    global_repl_state_async.status = PARSE_NULL;
+    global_repl_state_async.prompt_type = 1;
+    global_repl_state_async.browselevel = 0;
+    global_repl_state_async.bufp = NULL;
 
     R_IoBufferWriteReset(&R_ConsoleIob);
-    state.buf[0] = '\0';
-    state.buf[CONSOLE_BUFFER_SIZE] = '\0';
-    /* stopgap measure if line > CONSOLE_BUFFER_SIZE chars */
-    state.bufp = state.buf;
-    if(R_Verbose)
-	REprintf(" >R_ReplConsole(): before \"for(;;)\" {main.c}\n");
-    for(;;) {
-	status = Rf_ReplIteration(rho, savestack, browselevel, &state);
-	if(status < 0) {
-	  if (state.status == PARSE_INCOMPLETE)
-	    error(_("unexpected end of input"));
-	  return;
-	}
-    }
+
+    global_repl_state_async.buf[0] = '\0';
+    global_repl_state_async.buf[CONSOLE_BUFFER_SIZE] = '\0';
+    global_repl_state_async.bufp = global_repl_state_async.buf;
+    global_rho_async = rho;
+    global_savestack_async = savestack;
+    global_browselevel_async = browselevel;
+
+    Rf_ReplIteration(global_rho_async, global_savestack_async, global_browselevel_async, &global_repl_state_async);
 }
 
 
@@ -647,7 +672,7 @@
 #ifdef HAVE_STACK_T
 static stack_t sigstk;
 #else
-static struct sigaltstack sigstk;
+//static struct sigaltstack sigstk;
 #endif
 static void *signal_stack;
 
@@ -667,8 +692,8 @@
 	    sigstk.ss_sp = signal_stack;
 	    sigstk.ss_size = SIGSTKSZ + R_USAGE;
 	    sigstk.ss_flags = 0;
-	    if(sigaltstack(&sigstk, NULL) < 0)
-		warning("failed to set alternate signal stack");
+           //if(sigaltstack(&sigstk, NULL) < 0)
+           //  warning("failed to set alternate signal stack");
 	} else
 	    warning("failed to allocate alternate signal stack");
 	sa.sa_sigaction = sigactionSegv;
@@ -1128,7 +1153,7 @@
 	check_session_exit();
     R_GlobalContext = R_ToplevelContext = R_SessionContext = &R_Toplevel;
     R_ReplConsole(R_GlobalEnv, 0, 0);
-    end_Rmainloop(); /* must go here */
+    // end_Rmainloop(); /* must go here */
 }
 
 void mainloop(void)
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/dynload.c R-4.1.2_web/src/unix/dynload.c
--- R-4.1.2/src/unix/dynload.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/unix/dynload.c	2022-01-13 21:58:17.099380100 +0000
@@ -79,14 +79,15 @@
     int openFlag = 0;
 
     openFlag = computeDLOpenFlag(asLocal, now);
-    handle = (void *) dlopen(path,openFlag);
+    //handle = (void *) dlopen(path,openFlag);
+    handle = (void*) path;
 
     return(handle);
 }
 
 static void closeLibrary(HINSTANCE handle)
 {
-    dlclose(handle);
+    //dlclose(handle);
 }
 
  /*
@@ -200,7 +201,8 @@
 static DL_FUNC R_local_dlsym(DllInfo *info, char const *name)
 {
     fn_ptr tmp;
-    tmp.p = dlsym(info->handle, name);
+    //tmp.p = dlsym(info->handle, name);
+    tmp.p = dlsym(RTLD_DEFAULT, name);
     return tmp.fn;
 }
 
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/sys-std.c R-4.1.2_web/src/unix/sys-std.c
--- R-4.1.2/src/unix/sys-std.c	2021-09-28 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/unix/sys-std.c	2022-01-19 13:26:13.705584920 +0000
@@ -49,6 +49,7 @@
 #include <R_ext/Riconv.h>
 #include <R_ext/Print.h> // for REprintf
 #include <R_ext/RS.h> // for Calloc
+#include "Parse.h"
 
 #define __SYSTEM__
 /* includes <sys/select.h> and <sys/time.h> */
@@ -949,6 +950,12 @@
 /* Fill a text buffer from stdin or with user typed console input. */
 static void *cd = NULL;
 
+
+#include <emscripten/fetch.h>
+#include <emscripten.h>
+void repl_read_success(emscripten_fetch_t *fetch);
+void repl_read_fail(emscripten_fetch_t *fetch);
+
 int attribute_hidden
 Rstd_ReadConsole(const char *prompt, unsigned char *buf, int len,
 		 int addtohistory)
@@ -1026,8 +1033,8 @@
 	else
 #endif /* HAVE_LIBREADLINE */
 	{
-	    fputs(prompt, stdout);
-	    fflush(stdout);
+           //fputs(prompt, stdout);
+           //fflush(stdout);
 	}
 
 	if(R_InputHandlers == NULL)
@@ -1085,10 +1092,16 @@
 		else
 #endif /* HAVE_LIBREADLINE */
 		{
-		    if(fgets((char *)buf, len, stdin) == NULL)
-			return 0;
-		    else
-			return 1;
+                    char scr[1024];
+                    sprintf(scr, "___terminal::read::%s", prompt);
+                    emscripten_fetch_attr_t attr;
+                    emscripten_fetch_attr_init(&attr);
+                    strcpy(attr.requestMethod, "GET");
+                    attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY;
+                    attr.onsuccess = repl_read_success;
+                    attr.onerror = repl_read_fail;
+                    emscripten_fetch(&attr, scr);
+                    return 0;
 		}
 	    }
 	}
@@ -1334,7 +1347,7 @@
     R_ReadConsole("Enter file name: ", (unsigned char *)buf, len, 0);
     namelen = strlen(buf);
     bufp = &buf[namelen - 1];
-    while (bufp >= buf && isspace((int)*bufp))
+    while (bufp >= buf && ((char)*bufp == ' ' || (char)*bufp == '\t' ))
 	*bufp-- = '\0';
     return (int) strlen(buf);
 }
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/sys-unix.c R-4.1.2_web/src/unix/sys-unix.c
--- R-4.1.2/src/unix/sys-unix.c	2021-04-19 22:02:06.000000000 +0000
+++ R-4.1.2_web/src/unix/sys-unix.c	2022-01-12 16:33:53.612438356 +0000
@@ -237,7 +237,8 @@
     /* docs say this is rounded to the nearest ms */
     double et = currentTime() - StartTime;
     data[2] = 1e-3 * rint(1000*et);
-#ifdef HAVE_GETRUSAGE
+//#ifdef HAVE_GETRUSAGE
+#if 0
     /* all known current OSes */
     struct rusage self, children;
     getrusage(RUSAGE_SELF, &self);
@@ -445,8 +446,8 @@
     sigprocmask(SIG_BLOCK, &ss, &unblocked_ss);
 
     int saveerrno = errno;
-    while((wres = waitpid(tost.child_pid, wstatus, WNOHANG)) == 0)
-	sigsuspend(&unblocked_ss);
+    //while((wres = waitpid(tost.child_pid, wstatus, WNOHANG)) == 0)
+    //    sigsuspend(&unblocked_ss);
 
     if (errno == EINTR)
 	/* EINTR is not really an error but expected situation here, however,
diff -ur --exclude '*.o' --exclude '*.d' --exclude '*.so' --exclude '*.a' --exclude '*.s' --exclude Makefile --exclude Makeconf --exclude libtool --exclude config.log R-4.1.2/src/unix/system.c R-4.1.2_web/src/unix/system.c
--- R-4.1.2/src/unix/system.c	2021-04-20 23:15:01.000000000 +0100
+++ R-4.1.2_web/src/unix/system.c	2022-01-19 15:21:14.958574421 +0000
@@ -133,6 +133,7 @@
     }
 }
 
+#undef HAVE_GETRLIMIT
 #if defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT)
 /*
   Needed by AIX and formerly by macOS (but not by POSIX).
