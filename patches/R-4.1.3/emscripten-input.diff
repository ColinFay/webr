Index: R-4.1.3/src/main/main.c
===================================================================
--- R-4.1.3.orig/src/main/main.c
+++ R-4.1.3/src/main/main.c
@@ -306,6 +306,88 @@ Rf_ReplIteration(SEXP rho, int savestack
     return(0);
 }
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#include <emscripten/fetch.h>
+
+struct EM_ReplContext {
+    R_ReplState state;
+    SEXP rho;
+    int savestack;
+    int browselevel;
+} EM_ctx;
+
+int EMSCRIPTEN_KEEPALIVE run_R_from_JS(unsigned char* evalString, unsigned int n) {
+    char *endline;
+    int status;
+
+    R_IoBufferReadReset(&R_ConsoleIob);
+    R_IoBufferWriteReset(&R_ConsoleIob);
+    if(SETJMP(R_ToplevelContext->cjmpbuf) > 0){
+        return -1;
+    }
+
+    unsigned char *buf = (unsigned char *) malloc(n+2);
+    strncpy((char*) buf, (char*)evalString, n);
+    buf[n] = '\n';
+    buf[n+1] = '\0';
+    EM_ctx.state.bufp = buf;
+
+    while((endline = strchr((const char *)EM_ctx.state.bufp, '\n'))){
+        int crlf = 0;
+        if(*(endline-1) == '\r')
+            memmove(endline-1, endline, strlen(endline) + 1);
+        status = Rf_ReplIteration(EM_ctx.rho, EM_ctx.savestack, EM_ctx.browselevel, &(EM_ctx.state));
+        if(status < 0) break;
+    }
+    free(buf);
+    free(evalString);
+    return 0;
+}
+
+void EMSCRIPTEN_KEEPALIVE EM_ReplRead(unsigned char* evalString, unsigned int n) {
+    memset(EM_ctx.state.buf, 0, CONSOLE_BUFFER_SIZE+1);
+
+    unsigned int limit = (n < CONSOLE_BUFFER_SIZE-2)?n:(CONSOLE_BUFFER_SIZE-2);
+    strncpy((char*)(EM_ctx.state.buf), (char*)evalString, limit);
+    EM_ctx.state.buf[limit] = '\n';
+    EM_ctx.state.buf[limit+1] = '\0';
+    EM_ctx.state.bufp = EM_ctx.state.buf;
+
+    emscripten_resume_main_loop();
+}
+
+void EM_ReplIteration(){
+    if(SETJMP(R_ToplevelContext->cjmpbuf) > 0){
+        R_IoBufferReadReset(&R_ConsoleIob);
+        R_IoBufferWriteReset(&R_ConsoleIob);
+        EM_ctx.state.prompt_type = 1;
+        memset(EM_ctx.state.buf, 0, CONSOLE_BUFFER_SIZE+1);
+    }
+    Rf_ReplIteration(EM_ctx.rho, EM_ctx.savestack, EM_ctx.browselevel, &(EM_ctx.state));
+}
+
+static void R_ReplConsole(SEXP rho, int savestack, int browselevel)
+{
+    EM_ctx.state.status = PARSE_NULL;
+    EM_ctx.state.prompt_type = 1;
+    EM_ctx.state.browselevel = 0;
+    EM_ctx.state.bufp = NULL;
+
+    R_IoBufferWriteReset(&R_ConsoleIob);
+    EM_ctx.state.buf[0] = '\0';
+    EM_ctx.state.buf[CONSOLE_BUFFER_SIZE] = '\0';
+    EM_ctx.state.bufp = EM_ctx.state.buf;
+
+    EM_ctx.rho = rho;
+    EM_ctx.savestack = savestack;
+    EM_ctx.browselevel = browselevel;
+    if(R_Verbose)
+        REprintf(" >R_ReplConsole(): before \"for(;;)\" {main.c}\n");
+
+    emscripten_set_main_loop(EM_ReplIteration, -1, 0);
+}
+#else
 static void R_ReplConsole(SEXP rho, int savestack, int browselevel)
 {
     int status;
@@ -327,6 +409,7 @@ static void R_ReplConsole(SEXP rho, int 
 	}
     }
 }
+#endif
 
 
 static unsigned char DLLbuf[CONSOLE_BUFFER_SIZE+1], *DLLbufp;
@@ -1118,12 +1201,14 @@ extern SA_TYPE SaveAction; /* from src/m
 
 static void end_Rmainloop(void)
 {
+#ifndef __EMSCRIPTEN__
     /* refrain from printing trailing '\n' in no-echo mode */
     if (!R_NoEcho)
 	Rprintf("\n");
     /* run the .Last function. If it gives an error, will drop back to main
        loop. */
     R_CleanUp(SA_DEFAULT, 0, 1);
+#endif
 }
 
 void run_Rmainloop(void)
Index: R-4.1.3/src/unix/sys-std.c
===================================================================
--- R-4.1.3.orig/src/unix/sys-std.c
+++ R-4.1.3/src/unix/sys-std.c
@@ -61,6 +61,7 @@
 
 #ifdef __EMSCRIPTEN__
 #include <ctype.h>              /* for isspace */
+#include "Parse.h"
 #endif
 
 extern SA_TYPE SaveAction;
@@ -949,6 +950,9 @@ handleInterrupt(void)
 }
 #endif /* HAVE_LIBREADLINE */
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 
 /* Fill a text buffer from stdin or with user typed console input. */
 static void *cd = NULL;
@@ -1030,8 +1034,12 @@ Rstd_ReadConsole(const char *prompt, uns
 	else
 #endif /* HAVE_LIBREADLINE */
 	{
+#ifdef __EMSCRIPTEN__
+        EM_ASM(globalThis.Module.setPrompt(UTF8ToString($0)), prompt);
+#else
 	    fputs(prompt, stdout);
 	    fflush(stdout);
+#endif
 	}
 
 	if(R_InputHandlers == NULL)
@@ -1089,10 +1097,15 @@ Rstd_ReadConsole(const char *prompt, uns
 		else
 #endif /* HAVE_LIBREADLINE */
 		{
+#ifdef __EMSCRIPTEN__
+		    emscripten_pause_main_loop();
+		    return 0;
+#else
 		    if(fgets((char *)buf, len, stdin) == NULL)
 			return 0;
 		    else
 			return 1;
+#endif
 		}
 	    }
 	}
