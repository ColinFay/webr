Index: R-4.1.3/src/main/main.c
===================================================================
--- R-4.1.3.orig/src/main/main.c
+++ R-4.1.3/src/main/main.c
@@ -1139,6 +1139,121 @@ void mainloop(void)
     run_Rmainloop();
 }
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#include <emscripten/fetch.h>
+
+/* TODO: This patch should be moved to an external emscripten SIDE_MODULE
+ * This will help to keep webR features separate from required patches to R core
+ */
+struct eval_args {
+    const char *str;
+    SEXP env;
+};
+
+SEXP eval_tryCatch_body(void *data) {
+    struct eval_args *args = (struct eval_args*) data;
+    return R_ParseEvalString(args->str, args->env);
+}
+
+SEXP eval_tryCatch_capture(SEXP cond, void *hdata) {
+    *((SEXP *)hdata) = cond;
+    return R_NilValue;
+}
+
+#define BUFSIZE 8192
+SEXP eval_tryCatch_stderr(SEXP cond, void *hdata) {
+    char errbuf[BUFSIZE];
+    Rsnprintf_mbcs(errbuf, BUFSIZE, _("Error: "));
+    char *p = errbuf + strlen(errbuf);
+    Rsnprintf_mbcs(p, BUFSIZE - strlen(errbuf), R_curErrorBuf());
+    PrintWarnings();
+    REprintf("%s\n", errbuf);
+    return R_NilValue;
+}
+
+void eval_tryCatch_finally(void *fdata) {}
+
+SEXP EMSCRIPTEN_KEEPALIVE evalRCode(
+    const char *str,
+    SEXP env,
+    int handlers,
+    int conditions,
+    int streams
+) {
+    if (!env) env = R_GlobalEnv;
+    int old_out_con = R_OutputCon;
+    int old_err_con = R_ErrorCon;
+
+    SEXP ret = PROTECT(allocVector(VECSXP, 4));
+    SEXP hdata, fdata, out, err, out_con, err_con;
+    hdata = fdata = out = err = R_NilValue;
+    SEXP (*tryCatch_handler)(SEXP, void *);
+
+
+    if (streams) {
+        out_con = PROTECT(eval(
+            lang3(install("textConnection"), R_NilValue, mkString("w")),
+            R_BaseEnv
+        ));
+        err_con = PROTECT(eval(
+            lang3(install("textConnection"), R_NilValue, mkString("w")),
+            R_BaseEnv
+        ));
+        eval(lang2(install("sink"), out_con), R_BaseEnv);
+        eval(lang4(install("sink"), err_con, R_FalseValue,
+            mkString("message")), R_BaseEnv);
+    }
+
+    struct eval_args data = { str, env };
+    if (handlers) {
+        SEXP conds;
+        conds = PROTECT(mkString("error"));
+        if (conditions) {
+            tryCatch_handler = &eval_tryCatch_capture;
+        } else {
+            tryCatch_handler = &eval_tryCatch_stderr;
+        }
+        SET_VECTOR_ELT(ret, 0, R_tryCatch(
+            &eval_tryCatch_body,
+            &data,
+            conds,
+            tryCatch_handler,
+            &hdata,
+            NULL,
+            NULL
+        ));
+        UNPROTECT(1); // conds
+    } else {
+        SET_VECTOR_ELT(ret, 0, eval_tryCatch_body(&data));
+    }
+
+    PrintWarnings();
+
+    if (streams) {
+        eval(lang4(install("sink"), R_NilValue, R_FalseValue,
+            mkString("message")), R_BaseEnv);
+        eval(lang2(install("sink"), R_NilValue), R_BaseEnv);
+        out = PROTECT(eval(
+            lang2(install("textConnectionValue"), out_con),
+            R_BaseEnv
+        ));
+        err = PROTECT(eval(
+            lang2(install("textConnectionValue"), err_con),
+            R_BaseEnv
+        ));
+        UNPROTECT(4); // out, err, out_con, err_con
+    }
+
+    SET_VECTOR_ELT(ret, 1, out);
+    SET_VECTOR_ELT(ret, 2, err);
+    SET_VECTOR_ELT(ret, 3, hdata);
+    UNPROTECT(1); // ret
+
+    return ret;
+}
+#endif
+
 /*this functionality now appears in 3
   places-jump_to_toplevel/profile/here */
 
